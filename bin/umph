#!/usr/bin/perl
# -*- coding: ascii -*-

# umph
# Copyright (C) 2010-2011  Toni Gundogdu <legatvs@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

use warnings;
use strict;
use feature 'say';

binmode STDOUT, ":utf8";
binmode STDERR, ":utf8";

use version 0.77 (); our $VERSION = version->declare("0.2.0");

use Getopt::ArgvFile(home => 1, startupFilename => [qw(.umphrc)]);
use Getopt::Long qw(:config bundling);
use Carp qw(croak);

exit main();

sub print_version
{
  say "umph version $VERSION
Copyright (C) 2010-2011  Toni Gundogdu
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.";
  exit 0;
}

sub print_help
{
  require Pod::Usage;
  Pod::Usage::pod2usage(-exitstatus => 0, -verbose => 1);
}

use constant MAX_RESULTS_LIMIT => 50;    # Refer to http://is.gd/OcSjwU
my %config;

sub check_max_results_value
{
  if ($config{max_results} > MAX_RESULTS_LIMIT)
  {
    say STDERR
      "WARNING --max-results exceeds max. accepted value, using "
      . MAX_RESULTS_LIMIT
      . " instead";
    $config{max_results} = MAX_RESULTS_LIMIT;
  }
}

sub init
{
  GetOptions(
             \%config,
             'type|t=s',
             'start_index|start-index|s=i',
             'max_results|max-results|m=i',
             'interactive|i',
             'all|a',
             'json',
             'csv',
             'proxy=s',
             'no_proxy|no-proxy',
             'quiet|q',
             'version' => \&print_version,
             'help'    => \&print_help,
            ) or exit 1;

  print_help if scalar @ARGV == 0;

  $config{type}        ||= 'p';    # Default to "playlist".
  $config{start_index} ||= 1;      # Default to 1.
  $config{max_results} ||= 25;     # Default 25.

  check_max_results_value;
}

sub spew_qe {print STDERR @_ unless $config{quiet}}

my @items;

sub main
{
  init;
  spew_qe "Checking ... ";

  require LWP;
  my $a = new LWP::UserAgent;
  $a->env_proxy;    # http://search.cpan.org/perldoc?LWP::UserAgent
  $a->proxy('http', $config{proxy}) if $config{proxy};
  $a->no_proxy('') if $config{no_proxy};

  require XML::DOM;
  my $p = new XML::DOM::Parser(LWP_UserAgent => $a);
  my $s = $config{start_index};
  my $m = $config{all} ? MAX_RESULTS_LIMIT : $config{max_results};

  while (1)
  {
    my $doc  = $p->parsefile(from_arg($ARGV[0], $s, $m));
    my $root = $doc->getDocumentElement;
    my $n    = 0;
    for my $entry ($root->getElementsByTagName("entry"))
    {
      my $t = to_item($entry, "title")->getFirstChild->getNodeValue;
      my $l = to_item($entry, "link")->getAttributeNode("href")->getValue;
      my %data = (title => $t, url => $l, selected => 1);
      push @items, \%data;
      spew_qe((++$n % 5 == 0) ? " " : ".");
      ++$s;
    }
    $doc->dispose;

    last if $n == 0 or not $config{all};
  }

  spew_qe "done.\n";

  croak "error: nothing found\n" if scalar @items == 0;

  prompt() if $config{interactive};

  say qq/{\n  "video": [/ if $config{json};

  my $i = 0;

  foreach (@items)
  {
    if ($_->{selected} or not $config{interactive})
    {
      ++$i;

      my $t = $_->{title} || "";
      $t =~ s/"/\\"/g;

      if ($config{json})
      {
        say "," if $i > 1;
        say "    {";
        say qq/      "title": "$t",/;
        say qq/      "url": "$_->{url}"/;
        print "    }";
      }
      elsif ($config{csv}) {say qq/"$t","$_->{url}"/}
      else                 {say "$_->{url}"}
    }
  }

  say "\n  ]\n}" if $config{json};
  0;
}

use constant GURL => "http://gdata.youtube.com/feeds/api";

sub from_arg
{
  my ($arg0, $s, $m) = @_;

  my $u;
  if ($config{type} eq "u" or $config{type} eq "uploads")
  {
    $u = GURL . "/users/$arg0/uploads?v=2";
  }
  elsif ($config{type} eq "f" or $config{type} eq "favorites")
  {
    $u = GURL . "/users/$arg0/favorites?v=2";
  }
  else
  {
    $u = GURL . "/playlists/$arg0?v=2";
  }

  $u .= "&start-index=$s";
  $u .= "&max-results=$m";
}

sub to_item
{
  my ($entry, $name) = @_;
  $entry->getElementsByTagName($name)->item(0);
}

my $done = 0;

sub prompt
{
  my %cmds = (
              'h' => \&help,
              'q' => sub {exit 0},
              'd' => sub {$done = 1},
              'l' => \&list,
              'a' => \&select_all,
              'n' => \&select_none,
              'r' => \&revert_selection,
             );

  say STDERR qq/Enter prompt. Type "help" to get a list of commands./;
  list();

  use constant P => "(umph) ";

  while (not $done)
  {
    print STDERR P;

    my $ln = <STDIN>;
    next unless $ln;
    chomp $ln;

    if ($ln =~ /(\d+)/) {toggle_number($1)}
    else
    {
      next if $ln !~ /(\w)/;
      $cmds{$1}() if defined $cmds{$1};
    }
  }
}

sub toggle_number
{
  my $i = (shift) - 1;
  if ($i >= 0 && exists $items[$i])
  {
    $items[$i]->{selected} = not $items[$i]->{selected};
    list();
  }
  else {say STDERR "error: out of range"}
}

sub help
{
  say STDERR qq/Commands:
  help      .. this
  list      .. list found videos (> indicates selected)
  all       .. select all videos
  none      .. select none
  revert    .. revert selection
  (number)  .. toggle (select, unselect) video, see list output
  dump      .. dump selected video urls to stdout and exit
  quit      .. terminate program
Command name abbreviations are allowed, e.g. "a" instead of "all"./;
}

sub list
{
  my $i = 0;
  foreach (@items)
  {
    printf STDERR "%2s%02d: $_->{title}\n", $_->{selected}
      ? ">"
      : "",
      ++$i;
  }
}

sub select_all
{
  $_->{selected} = 1 foreach @items;
  list();
}

sub select_none
{
  $_->{selected} = 0 foreach @items;
  list();
}

sub revert_selection
{
  $_->{selected} = not $_->{selected} foreach @items;
  list();
}

__END__

=head1 SYNOPSIS

umph [-q] [-i] [-a] [--csv | --json] [-t E<lt>typeE<gt>]
     [--proxy E<lt>addrE<gt> | --no-proxy]
     [E<lt>playlist_idE<gt> | E<lt>usernameE<gt>]

=head2 OPTIONS

     --help                     Print help and exit
     --version                  Print version and exit
 -q, --quiet                    Be quiet
 -i, --interactive              Run in interactive mode
 -t, --type arg (=p)            Get feed type
 -s, --start-index arg (=1)     Index of first matching result
 -m, --max-results arg (=25)    Max number of results included
 -a, --all                      Get all items
     --json                     Print details in JSON
     --csv                      Print details in CSV
     --proxy arg (=http_proxy)  Use proxy for HTTP connections
     --no-proxy                 Disable use of HTTP proxy

=cut

# vim: set ts=2 sw=2 tw=72 expandtab:
