#!/usr/bin/perl
# -*- coding: ascii -*-

#
# Copyright (C) 2010 Toni Gundogdu <legatvs@gmail.com>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

use warnings;
use strict;

binmode( STDOUT, ":utf8" );
binmode( STDERR, ":utf8" );

use Getopt::ArgvFile( home => 1, startupFilename => [qw(.umphrc)] );
use Getopt::Long qw(:config bundling);

my $VERSION = "0.1.4";
my %config;
my @entries;
my $done = 0;

init();
main();
exit 0;

sub init {
    GetOptions(
        \%config,
        'type|t=s',
        'interactive|i',
        'csv',
        'version|v' => \&print_version,
        'license'   => \&print_license,
        'help|h'    => \&print_help,
    ) or exit(1);

    $config{type} ||= 'p'; # Default to "playlist".
}

sub print_version {
    print "umph version $VERSION\n";
    exit 0;
}

sub print_license {
    print
        "Copyright (C) 2010 Toni Gundogdu. GNU GPL v3+. This is free software;
see the source for copying conditions. There is NO warranty; not even
for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
";
    exit 0;
}

sub print_help {
    require Pod::Usage;
    Pod::Usage::pod2usage( -exitstatus => 0, -verbose => 1 );
}

sub main {

    print_help if scalar @ARGV == 0;

    print STDERR "Checking ...";

    require XML::DOM;

    my $p    = new XML::DOM::Parser;
    my $doc  = $p->parsefile (from_arg ($ARGV[0]));
    my $root = $doc->getDocumentElement;

    for my $entry ( $root->getElementsByTagName("entry") ) {

        my $title = to_item( $entry, "title" )->getFirstChild->getNodeValue;

        my $link
            = to_item( $entry, "link" )->getAttributeNode("href")->getValue;

        my %data = ( title => $title, url => $link, selected => 1 );
        push @entries, \%data;

        print STDERR ".";
    }

    print STDERR "done.\n";

    $doc->dispose;

    print STDERR "error: nothing found.\n" and exit 1
        unless scalar @entries;

    prompt() if $config{interactive};

    foreach (@entries) {
        if ($_->{selected} or not $config{interactive}) {
            $config{csv}
                ? print qq/"$_->{title}","$_->{url}"\n/
                : print "$_->{url}\n";
        }
    }
}

sub from_arg {
    my ($arg0, $u) = @_;

    if ($config{type} eq "u" or $config{type} eq "uploads")
        { $u = "http://gdata.youtube.com/feeds/api/users/$arg0/uploads?v=2"; }
    elsif ($config{type} eq "f" or $config{type} eq "favorites")
        { $u = "http://gdata.youtube.com/feeds/api/users/$arg0/favorites?v=2"; }
    else
        { $u = "http://gdata.youtube.com/feeds/api/playlists/$arg0?v=2"; }

    return $u;
}

sub to_item {
    my ( $entry, $name ) = @_;
    return $entry->getElementsByTagName($name)->item(0);
}

sub prompt {

    my %cmds = (
        'h' => \&help,
        'q' => \&quit,
        'l' => \&list,
        'd' => \&dump,
        'a' => \&select_all,
        'n' => \&select_none,
        'r' => \&revert_selection,
    );

    print STDERR "Enter prompt. Type \"help\" to get a list of commands.\n";
    list();

    my $p = "(umph) ";

    while ( !$done ) {
        print STDERR $p;
        my $ln = <STDIN>;
        next if !$ln;
        chomp $ln;
        if ( $ln =~ /(\d+)/ ) {
            toggle_number($1);
        }
        else {
            next if $ln !~ /(\w)/;
            $cmds{$1}() if defined $cmds{$1};
        }
    }
}

sub toggle_number {
    my $i = (shift) - 1;
    if ( $i >= 0 && exists $entries[$i] ) {
        $entries[$i]->{selected} = !$entries[$i]->{selected};
        list();
    }
    else {
        printf STDERR "error: out of range\n";
    }
}

sub help {
    print STDERR "Commands:
  help      .. this
  list      .. display playlist entries (> indicates selection)
  all       .. select all videos
  none      .. select none
  revert    .. revert selection
  (number)  .. toggle (select, unselect) video, see list output
  dump      .. dump selected video urls to stdout and exit
  quit      .. terminate program
Command name abbreviations are allowed, e.g. \"a\" instead of \"all\".
";
}

sub quit {
    exit 0;
}

sub list {
    my $i = 0;
    foreach (@entries) {
        printf STDERR "%2s%02d: $_->{title}\n", $_->{selected} ? ">" : "",
            ++$i;
    }
}

sub dump {
    $done = 1;
}

sub select_all {
    $_->{selected} = 1 foreach @entries;
    list();
}

sub select_none {
    $_->{selected} = 0 foreach @entries;
    list();
}

sub revert_selection {
    $_->{selected} = !$_->{selected} foreach @entries;
    list();
}

__END__

=head1 NAME

umph - Command line tool for parsing video links from Youtube feeds

=head1 SYNOPSIS

umph [-t E<lt>typeE<gt>] [E<lt>playlist_idE<gt> | E<lt>usernameE<gt>]

=head1 DESCRIPTION

umph is a command line tool for parsing video links from Youtube feeds,
such as playlists, favorites and uploads. The parsed video links are
printed to the standard output each separated with a newline.

If you need to select the videos, use the C<--interactive> switch.

=head1 OPTIONS

 -h, --help             print help and exit
 -v, --version          print version and exit
     --license          print license and exit
 -t, --type =arg        feed type, default is playlist
 -i, --interactive      be interactive
 --csv                  print details in csv

=head1 OPTION DESCRIPTIONS

=over 4

=item B<-h, --help>

Print help and exit.

=item B<-v, --version>

Print version and exit.

=item B<--license>

Print license and exit.

=item B<-t, --type>=I<arg>

Specifies the feed type to get. I<arg> can be one of the following:

  p, playlist  (arg0 will be treated as playlist ID)
  f, favorites (arg0 will be treated as username)
  u, uploads   (same)

Default is "p" (playlist). See also L</EXAMPLES>.

=item B<-i, --interactive>

Enable interactive prompt which can be used to select the videos from the
feed. By default umph selects all of the feed items.

=item B<--csv>

Print details in CSV ("$title","$url"\n).

=back

=head1 EXAMPLES

=over 4

=item umph AAF3A1D0CA1E304F

Fetch and parse playlist "AAF3A1D0CA1E304F".

=item umph -t f youtube

Fetch and parse favorites for user "youtube".

=item umph -t u youtube

Fetch and parse uploads for user "youtube".

=item umph AAF3A1D0CA1E304F | cclive -f sd_270p

Print the parsed playlist items (links) to stdout, use C<cclive(1)>
to download them.

Use C<--interactive> if you want to select the videos to be downloaded.

=back

=head1 EXIT STATUS

Exits 0 on success, otherwise 1.

=head1 FILES

=over 4

=item $HOME/.umphrc, for example:

echo "--interactive" >> ~/.umphrc

=back

=head1 OTHER

=over 4

=item B<http_proxy>

umph depends on XML::DOM which uses LWP::UserAgent to retrieve
the playlist data. Note that LWP::UserAgent reads http_proxy
environment setting. e.g.:

    env http_proxy=http://foo:1234 umph AAF3A1D0CA1E304F

=item B<Project>

<http://umph.googlecode.com/>

=item B<Development repository>

<git://repo.or.cz/umph.git>

e.g. git clone git://repo.or.cz/umph.git

=back

=head1 SEE ALSO

C<cclive(1)> C<clive(1)>

=head1 AUTHOR

Toni Gundogdu <legatvs gmail com>

=cut


