#!/usr/bin/perl
# -*- coding: ascii -*-

#
# Copyright (C) 2010 Toni Gundogdu <legatvs@gmail.com>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

use warnings;
use strict;

binmode( STDOUT, ":utf8" );
binmode( STDERR, ":utf8" );

use Getopt::ArgvFile( home => 1, startupFilename => [qw(.umphrc)] );
use Getopt::Long qw(:config bundling);

my $VERSION = "0.1.5";
my %config;
my @entries;
my $done = 0;

exit main();

sub init {

    GetOptions(
        \%config,
        'type|t=s',
        'start_index|start-index|s=s',
        'max_results|max-results|m=s',
        'interactive|i',
        'csv',
        'version|v' => \&print_version,
        'license'   => \&print_license,
        'help|h'    => \&print_help,
    ) or exit(1);

    $config{type} ||= 'p';       # Default to "playlist".
    $config{start_index} ||= 1;  # Default to 1.
    $config{max_results} ||= 25; # Default 25.
}

sub print_version {
    print "umph version $VERSION\n";
    exit 0;
}

sub print_license {
    print
"Copyright (C) 2010 Toni Gundogdu. GNU GPL v3+. This is free software;
see the source for copying conditions. There is NO warranty; not even
for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
";
    exit 0;
}

sub print_help {
    require Pod::Usage;
    Pod::Usage::pod2usage( -exitstatus => 0, -verbose => 1 );
}

sub main {

    init();

    print_help if scalar @ARGV == 0;

    print STDERR "Checking ...";

    require XML::DOM;

    my $p    = new XML::DOM::Parser;
    my $doc  = $p->parsefile (from_arg ($ARGV[0]));
    my $root = $doc->getDocumentElement;

    for my $entry ( $root->getElementsByTagName("entry") ) {

        my $title = to_item( $entry, "title" )->getFirstChild->getNodeValue;

        my $link =
            to_item( $entry, "link" )->getAttributeNode("href")->getValue;

        my %data = ( title => $title, url => $link, selected => 1 );

        push @entries, \%data;

        print STDERR ".";
    }

    print STDERR "done.\n";

    $doc->dispose;

    print STDERR "error: nothing found.\n" and return 1
        unless scalar @entries;

    prompt() if $config{interactive};

    foreach (@entries) {
        if ($_->{selected} or not $config{interactive}) {
            $config{csv}
                ? print qq/"$_->{title}","$_->{url}"\n/
                : print "$_->{url}\n";
        }
    }

    return 0;
}

sub from_arg {
    my ($arg0, $u) = @_;

    if ($config{type} eq "u" or $config{type} eq "uploads")
        { $u = "http://gdata.youtube.com/feeds/api/users/$arg0/uploads?v=2"; }
    elsif ($config{type} eq "f" or $config{type} eq "favorites")
        { $u = "http://gdata.youtube.com/feeds/api/users/$arg0/favorites?v=2"; }
    else
        { $u = "http://gdata.youtube.com/feeds/api/playlists/$arg0?v=2"; }

    $u .= "&start-index=$config{start_index}";
    $u .= "&max-results=$config{max_results}";

    return $u;
}

sub to_item {
    my ( $entry, $name ) = @_;
    return $entry->getElementsByTagName($name)->item(0);
}

sub prompt {

    my %cmds = (
        'h' => \&help,
        'q' => \&quit,
        'l' => \&list,
        'd' => \&dump,
        'a' => \&select_all,
        'n' => \&select_none,
        'r' => \&revert_selection,
    );

    print STDERR "Enter prompt. Type \"help\" to get a list of commands.\n";
    list();

    my $p = "(umph) ";

    while ( !$done ) {
        print STDERR $p;
        my $ln = <STDIN>;
        next if !$ln;
        chomp $ln;
        if ( $ln =~ /(\d+)/ ) {
            toggle_number($1);
        }
        else {
            next if $ln !~ /(\w)/;
            $cmds{$1}() if defined $cmds{$1};
        }
    }
}

sub toggle_number {
    my $i = (shift) - 1;
    if ( $i >= 0 && exists $entries[$i] ) {
        $entries[$i]->{selected} = !$entries[$i]->{selected};
        list();
    }
    else {
        printf STDERR "error: out of range\n";
    }
}

sub help {
    print STDERR "Commands:
  help      .. this
  list      .. list found videos (> indicates selected)
  all       .. select all videos
  none      .. select none
  revert    .. revert selection
  (number)  .. toggle (select, unselect) video, see list output
  dump      .. dump selected video urls to stdout and exit
  quit      .. terminate program
Command name abbreviations are allowed, e.g. \"a\" instead of \"all\".
";
}

sub list {
    my $i = 0;
    foreach (@entries) {
        printf STDERR "%2s%02d: $_->{title}\n", $_->{selected} ? ">" : "",
            ++$i;
    }
}

sub select_all {
    $_->{selected} = 1 foreach @entries;
    list();
}

sub select_none {
    $_->{selected} = 0 foreach @entries;
    list();
}

sub revert_selection {
    $_->{selected} = !$_->{selected} foreach @entries;
    list();
}

sub quit { exit 0; }

sub dump { $done = 1; }

__END__

=head1 NAME

umph - Command line tool for parsing video links from Youtube feeds

=head1 SYNOPSIS

umph [-i] [--csv] [-t E<lt>typeE<gt>] [E<lt>playlist_idE<gt> | E<lt>usernameE<gt>]

=head1 DESCRIPTION

umph is a command line tool for parsing video links from Youtube feeds,
such as playlists, favorites and uploads. The parsed video links are
printed to the standard output each separated with a newline.

If you need to select the videos, use the C<--interactive> switch.

=head1 OPTIONS

 -h, --help                 print help and exit
 -v, --version              print version and exit
     --license              print license and exit
 -t, --type =arg            feed type, default is playlist
 -s, --start-index =arg     index of first matching result
 -m, --max-results =arg     max number of results included
 -i, --interactive          be interactive
 --csv                      print details in csv

=head1 OPTION DESCRIPTIONS

=over 4

=item B<-h, --help>

Print help and exit.

=item B<-v, --version>

Print version and exit.

=item B<--license>

Print license and exit.

=item B<-t, --type>=I<arg>

Specifies the feed type to get. I<arg> can be one of the following:

  p, playlist  (arg0 will be treated as playlist ID)
  f, favorites (arg0 will be treated as username)
  u, uploads   (same)

Default is "p" (playlist). See also L</EXAMPLES>.

=item B<-s, --start-index>=I<arg>

"The start-index parameter specifies the index of the first matching result
that should be included in the result set. This parameter uses a one-based
index, meaning the first result is 1, the second result is 2 and so forth.

This parameter works in conjunction with the C<--max-results> parameter to
determine which results to return. For example, to request the second set
of 10 results, i.e. results 11-20, set the start-index parameter to 11
and the max-results parameter to 10."

  <http://code.google.com/apis/youtube/2.0/reference.html#start-indexsp>

umph defaults to 1.

=item B<-m, --max-results>=I<arg>

"The max-results parameter specifies the maximum number of results that
should be included in the result set.

This parameter works in conjunction with the C<--start-index>  parameter
to determine which results to return. For example, to request the second
set of 10 results, i.e. results 11-20, set the max-results parameter
to 10 and the start-index parameter to 11.

The default value of this parameter is 25, and the maximum value is 50.
However, for displaying lists of videos, we recommend that you set the
max-results parameter to 10."

  <http://code.google.com/apis/youtube/2.0/reference.html#max-resultssp>

umph defaults to 25.

=item B<-i, --interactive>

Enable interactive prompt which can be used to select the videos from the
feed. By default umph selects all of the feed items.

=item B<--csv>

Print details in CSV ("$title","$url"\n).

=back

=head1 EXAMPLES

=over 4

=item umph AAF3A1D0CA1E304F

Fetch and parse playlist "AAF3A1D0CA1E304F".

=item umph -s 11 -m 10 AAF3A1D0CA1E304F

Same as above but get the items 11-20 from the playlist.

=item umph -t f youtube

Fetch and parse favorites for user "youtube".

=item umph -t u youtube

Fetch and parse uploads for user "youtube".

=item umph AAF3A1D0CA1E304F | cclive -f sd_270p

Print the parsed playlist items (links) to stdout, use C<cclive(1)>
to download them.

=back

=head1 EXIT STATUS

Exits 0 on success, otherwise 1.

=head1 FILES

=over 4

=item $HOME/.umphrc, for example:

echo "--interactive" >> ~/.umphrc

=back

=head1 NOTES

=over 4

=item B<http_proxy>

umph depends on XML::DOM which uses LWP::UserAgent to fetch the data
over the network. LWP::UserAgent reads the http_proxy environment
setting. e.g.:

    env http_proxy=http://foo:1234 umph AAF3A1D0CA1E304F

=item B<Unavailable feeds>

Some feeds may have been set private by the Youtube users. umph
cannot currently fetch and parse those.

=item B<Project>

<http://umph.googlecode.com/>

=item B<Development repository>

<git://repo.or.cz/umph.git>

e.g. git clone git://repo.or.cz/umph.git

=back

=head1 SEE ALSO

C<cclive(1)> C<clive(1)>

=head1 AUTHOR

Toni Gundogdu <legatvs gmail com>

=cut


